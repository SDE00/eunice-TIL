# Today - 2025-04-15 (Tue)

## Scrub
- 자바스크립트의 실행 메커니즘과 런타임 구조에 대해 학습함으로써, 프론트엔드 코드의 동작 흐름을 더 깊이 이해함
- 협업 중 프론트엔드 상태 관리 방식에 대한 이야기를 계기로 **React 기반 상태 관리 프레임워크들**에 대해 조사 및 비교

---

## Learned

### JavaScript 엔진의 코드 실행 과정
- JS 엔진은 **소스코드를 파싱하고 실행 컨텍스트를 구성**한 뒤, 런타임에서 순차적으로 코드를 처리함
- 코드 실행 순서:
  1. 파싱 (Parsing) → AST(Abstract Syntax Tree) 생성
  2. 컴파일링 (JIT 등) → 바이트코드로 변환
  3. 실행 (Runtime) → 실행 컨텍스트 생성 및 콜스택 처리

### 메모리 구조: 메모리 힙 vs 콜 스택
| 영역 | 설명 |
|------|------|
| Memory Heap | 객체가 저장되는 메모리 영역 (동적으로 할당됨) |
| Call Stack | 함수 실행 순서를 기록하는 구조 (LIFO 방식) | 
"\n"

> 자바스크립트는 단일 스레드이므로 Call Stack이 꽉 차면 `Stack Overflow`가 발생할 수 있음

### 모듈 번들러 & 트랜스파일러

#### 모듈 번들러 (Module Bundler)
- 여러 JS 모듈을 하나의 번들 파일로 합치는 도구
- 대표 예시: **Webpack, Vite, Parcel**
- 역할: 의존성 관리, 코드 스플리팅, 최적화, 트리 쉐이킹 등

#### 트랜스파일러 (Transpiler)
- 최신 JS 문법을 **과거 브라우저에서도 실행 가능한 코드로 변환**
- 대표 예시: **Babel, SWC**
- 예: `async/await` → `Promise` 체인으로 변환

> 일반적으로 트랜스파일러 → 번들러 순으로 실행되며, Babel은 Webpack과 함께 쓰이는 경우가 많음

---

## React 상태 관리 체계 개요

### 상태 관리란?
- UI의 **상태(State)**를 일관되게 관리하고, 필요에 따라 갱신하여 렌더링을 트리거하는 구조

### 주요 라이브러리 비교
| 라이브러리 | 특징 |
|------------|------|
| Context API | React 내장, 가볍지만 구조가 커지면 한계 있음 |
| Redux | 전역 상태 관리의 대표주자. 미들웨어 연동, 디버깅 강력함 |
| Zustand | 보일러플레이트 줄이고, 훅 기반 간단한 상태 관리 |
| Recoil | React에 맞춘 선언형 상태 관리, 비동기와 전역 상태에 유리 |
| Jotai | 원자(atom) 기반의 단순한 전역 상태 관리 방식 |

> 프로젝트 복잡도, 팀 규모, 상태 공유 범위에 따라 **선택 기준이 달라짐**

---

## Keep
- JS 런타임 구조를 학습하며 비동기 흐름과 성능 병목이 발생하는 위치를 이해할 수 있었음
- React 상태 관리 기법이 단순 기능 이상으로 **아키텍처 구성과 개발 생산성에 큰 영향**을 준다는 점 인지함

## Problem
- 모듈 번들링과 트리 쉐이킹 개념은 이해했으나 실제 설정 과정(Webpack config 등)은 아직 미숙함
- Zustand, Recoil 등의 실제 코드 예시와 패턴 숙지가 필요함
